group_dif_flag <- dplyr::enquo(group_var) %>% as.character()
group_dif_flag2 <- group_dif_flag[2]
group_num <- group_vars(dataset) %>% length()
grouped <- if(any(names(dataset) == 'group_var1') == T){
grouped <- T
} else if(group_dif_flag2 != 'group_var'){
grouped <- T
} else if(is_grouped_df(dataset) == T){
grouped <- T
} else{
grouped <- F
}
# group_var_flag <- if(
#   any(names(frequencies) == 'group_var') == T
#   ){
#   group_var <- F
# }
# group_var <- if(
#   group_vars(dataset) %>% length() < 1 &
#   any(names(frequencies) == 'group_var') == F
#   ){
#   group_var <- F
# }
# group_var_flag <- if(any(names(dataset) == 'group_var') == T) {
#   dplyr::enquo(group_var)  #auto chooose group_var
# } else{
#   dplyr::enquo(group_var) #here is where user can specify group_var names
# }
# return(group_dif_flag2)
}
test <- test_fun(frequencies)
View(frequencies)
#new_group atuo feature
frequencies <- responses %>%
group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
# group_var = QSEX
)
test_fun <- function(dataset, group_var = group_var){
group_dif_flag <- dplyr::enquo(group_var) %>% as.character()
group_dif_flag2 <- group_dif_flag[2]
group_num <- group_vars(dataset) %>% length()
grouped <- if(any(names(dataset) == 'group_var1') == T){
grouped <- T
} else if(group_dif_flag2 != 'group_var'){
grouped <- T
} else if(is_grouped_df(dataset) == T){
grouped <- T
} else{
grouped <- F
}
# group_var_flag <- if(
#   any(names(frequencies) == 'group_var') == T
#   ){
#   group_var <- F
# }
# group_var <- if(
#   group_vars(dataset) %>% length() < 1 &
#   any(names(frequencies) == 'group_var') == F
#   ){
#   group_var <- F
# }
# group_var_flag <- if(any(names(dataset) == 'group_var') == T) {
#   dplyr::enquo(group_var)  #auto chooose group_var
# } else{
#   dplyr::enquo(group_var) #here is where user can specify group_var names
# }
# return(group_dif_flag2)
}
test <- test_fun(frequencies, groupvar1)
frequencies <- responses %>%
group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK)
#new_group atuo feature
frequencies <- responses %>%
group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
group_var = QSEX
)
#new_group atuo feature
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
# group_var = QSEX
)
#new_group atuo feature
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
# group_var = QSEX
)
##### Public functions #####
#' Run frequencies for multiple variables.
#'
#' @param dataset A dataframe.
#' @param ... The unquoted names of a set of variables in the dataframe. If nothing
#' is specified, the function runs a frequency on every column in given dataset.
#' @param stat Character, stat to run. Currently only 'percent' works (default: 'percent').
#' @param nas Boolean, whether or not to include NAs in the tabulation (default: T).
#' @param wt The unquoted name of a weighting variable in the dataframe (default: NULL).
#' @param prompt Boolean, whether or not to include the prompt in the dataframe (default: F).
#' @param digits Integer, number of significant digits for rounding (default: 2).
#' @return A dataframe with the variable names, prompts, values, labels, counts,
#' stats, and resulting calculations.
#' @examples
#' df <- data.frame(
#'   a = c(1, 2, 2, 3, 4, 2, NA),
#'   b = c(1, 2, 2, 3, 4, 1, NA),
#'   weights = c(0.9, 0.9, 1.1, 1.1, 1, 1, 1)
#' )
#'
#' freqs(df, a, b)
#' freqs(df, a, b, nas = FALSE)
#' freqs(df, a, b, wt = weights)
#' @export
freqs <- function(dataset, ..., stat = 'percent', nas = TRUE, wt = NULL, prompt = F, digits = 2, nas_group = TRUE) {
dataset <- group_factor(dataset, nas_group)
weight = dplyr::enquo(wt)
variables = dplyr::quos(...)
if (!length(variables)) {
# If no variables are specified in the function call,
# assume the user wants to run a frequency on all columns.
variables <- column_quos(dataset)
}
frequencies <- purrr::map_dfr(
.x = variables,
.f = function(variable) {
freq_var(dataset, !!variable, stat, nas, !!weight, prompt, digits)
}
)
frequencies <- group_rename(frequencies)
}
# Create a redundant function for convenience/backwards compatibility.
freq <- freqs
##### Private functions #####
group_factor <- function(dataset, nas_group){
grouping_vars <- dplyr::group_vars(dataset)
if(length(grouping_vars) > 1){ #if there are 2+ grouping vars
dataset <- group_factor2(dataset, grouping_vars, nas_group)
} else if(length(grouping_vars) == 1){ #1 grouping var
dataset <- group_factor1(dataset, grouping_vars, nas_group)
} else{ # no grouping vars
dataset <- dataset
}
}
group_factor2 <- function(dataset, grouping_vars, nas_group) {
group_flag <- dplyr::group_vars(dataset)[1] %>% as.symbol()
group_flag2 <- dplyr::group_vars(dataset)[2] %>% as.symbol()
if(nas_group == FALSE){
dataset <- dataset %>%
dplyr::filter(
!is.na(!!group_flag),
!is.na(!!group_flag2)
)
}
dataset <- dataset %>%
dplyr::ungroup() %>%
dplyr::mutate_at(
vars(
grouping_vars
),
list(~as_factor(.))
) %>%
dplyr::group_by(
!!group_flag,
!!group_flag2
)
}
group_factor1 <- function(dataset, grouping_vars, nas_group){
group_flag <- dplyr::group_vars(dataset)[1] %>% as.symbol()
if(nas_group == FALSE){
dataset <- dataset %>%
dplyr::filter(
!is.na(!!group_flag)
)
}
dataset <- dataset %>%
dplyr::ungroup() %>%
dplyr::mutate_at(
vars(
grouping_vars
),
list(~as_factor(.))
) %>%
dplyr::group_by(
!!group_flag
)
}
column_quos <- function(dataset, wt = NULL) {
col_names <- dataset %>% colnames()
if (is.grouped_df(dataset)) {
# Exclude grouping variables since they cannot be counted independent of groups.
grouping_vars <- dplyr::group_vars(dataset)
col_names <- setdiff(col_names, grouping_vars)
}
#Exclude weighting varaible from freqs in select
weight_name <- dplyr::enquo(wt) %>% as.character()
weight_name2 <- weight_name[2]
col_names <- setdiff(col_names, weight_name2)
col_syms <- col_names %>% dplyr::syms()
col_quos <- purrr::map(col_syms, dplyr::quo)
return(col_quos)
}
freq_var <- function(dataset, variable, stat = 'percent', nas = TRUE, wt = NULL, prompt = F, digits = 2) {
variable <- dplyr::enquo(variable)
weight <- dplyr::enquo(wt)
base <- ns(dataset, variable, weight, prompt)
if (stat == 'percent') {
freq_result <- base %>%
percents(nas, digits = digits)
}
return(freq_result)
}
ns <- function(dataset, variable, weight, prompt) {
counts <- if (class(dataset %>% dplyr::pull(!!variable)) %in% c('labelled','haven_labelled','haven_labelled_spss')) {
# Metadata is better if the given variable has labels
labelled_ns(dataset, variable, weight, prompt)
} else {
# Otherwise, use some sensible defaults
unlabelled_ns(dataset, variable, weight, prompt)
}
# Reorder because Scotty is OCD
if (prompt) {
counts %>%
dplyr::select(
variable,
prompt,
value,
label,
n
)
} else {
counts %>%
dplyr::select(
variable,
value,
label,
n
)
}
}
percents <- function(counts, include_nas, digits) {
# Filter out NAs if requested
if (! include_nas) {
counts <- counts %>%
dplyr::filter(
!is.na(value)
)
}
# Calculate and round to integer percentages
counts %>%
dplyr::mutate(
stat = 'percent',
result = (n / sum(n)) %>% round(digits)
)
}
labelled_ns <- function(dataset, variable, weight, prompt) {
# Extract the metadata from the labelled class
counts <- base_ns(dataset, variable, weight)
if (prompt) {
counts <- counts %>%
dplyr::mutate(
prompt = labelled::var_label(value)
)
}
counts <- counts %>%
dplyr::mutate(
label = labelled::to_factor(value) %>% as.character,
value = value %>% as.character
)
return(counts)
}
unlabelled_ns <- function(dataset, variable, weight, prompt) {
counts <- base_ns(dataset, variable, weight) %>%
dplyr::mutate(
label = value %>% as.character,
value = value %>% as.character
)
if (prompt) {
counts <- counts %>%
dplyr::mutate(
prompt = ''
)
}
return(counts)
}
base_ns <- function(dataset, variable, weight) {
dataset %>%
# When wt is NULL, it runs unweighted counts
dplyr::count(!!variable, wt = !!weight, .drop = F) %>%
dplyr::rename(value = !!variable) %>%
dplyr::mutate(
variable = dplyr::quo_name(variable)
)
}
group_rename <- function(dataset){
if(names(dataset)[1] != 'variable'){
if(names(dataset)[2] != 'variable'){ #if there are 2 grouping vars
dataset <- dataset %>%
dplyr::rename(
group_var1 = names(dataset)[1],
group_var2 = names(dataset)[2]
)
}else{ #if there is 1 grouping var
dataset <- dataset %>%
dplyr::rename(group_var = names(dataset)[1])
}
#NOT GROUPED
} else{
dataset <- dataset
}
}
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK)
#new_group atuo feature
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
# group_var = QSEX
)
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK)
is_grouped_df(frequencies)
test <- group_vars(frequencies) %>% length()
frequencies <- grouped_freqs %>%
rename(group_var = district)
View(frequencies)
frequencies <- responses %>% freqs(QWALKPARK)
View(frequencies)
test_fun <- function(dataset, group_var = group_var){
group_dif_flag <- dplyr::enquo(group_var) %>% as.character()
group_dif_flag2 <- group_dif_flag[2]
group_num <- group_vars(dataset) %>% length()
grouped <- if(any(names(dataset) == 'group_var1') == T){
grouped <- T
} else if(group_dif_flag2 != 'group_var'){
grouped <- T
} else if(is_grouped_df(dataset) == T){
grouped <- T
} else{
grouped <- F
}
# group_var_flag <- if(
#   any(names(frequencies) == 'group_var') == T
#   ){
#   group_var <- F
# }
# group_var <- if(
#   group_vars(dataset) %>% length() < 1 &
#   any(names(frequencies) == 'group_var') == F
#   ){
#   group_var <- F
# }
# group_var_flag <- if(any(names(dataset) == 'group_var') == T) {
#   dplyr::enquo(group_var)  #auto chooose group_var
# } else{
#   dplyr::enquo(group_var) #here is where user can specify group_var names
# }
# return(group_dif_flag2)
}
test <- test_fun(frequencies, groupvar1)
test <- test_fun(frequencies, group_var1)
### Final Function
order_label <- function(
dataset, #will likely be frequencies
label_var = label,
inherent_order_label = F,
group_var = F,
inherent_order_group = F,
label_specific = NA,
group_specific = NA,
stacked = 'NULL',
horizontal = F,
rev_label = F,
rev_group = F,
none_other = T,
topbox = NULL
) {
options(warn = -1) #check what these warning actually are...
###Flags
#Enquo flags
label_var_flag <- dplyr::enquo(label_var)
group_var_flag <- dplyr::enquo(group_var)
#Stacked flags: bars always inherently ordered
inherent_order_label = ifelse(
stacked != 'NULL',
T,
inherent_order_label
)
#Grouping flags
group_test <- dataset %>%
dplyr::mutate(
test = ifelse(
!!group_var_flag == F,
F,
T
)
)
grouped = ifelse(
group_test$test == T,
T,
F
)
#Flags for putting a specific label/group first
specifically_ordered = ifelse(
is.character(label_specific) == T,
T,
F
)
specifically_ordered_group = ifelse(
is.character(group_specific) == T,
T,
F
)
### Prep work
dataset <- reverse_label(dataset, grouped, !!group_var_flag, !!label_var_flag, rev_label)
### (1) ungrouped Section
if(grouped == F){
dataset <- section_ungrouped(dataset, grouped, specifically_ordered, inherent_order_label, stacked, label_specific)
### Arranging WITH grouping variables
} else{
### (2) Grouped Section: arranging for specific group and label to be first
dataset <- section_grouped_specifics(dataset, specifically_ordered, label_specific,inherent_order_label, group_var, inherent_order_group, group_specific, specifically_ordered_group, rev_group)
### (3) Grouped Section: arranging for specific group to be first
dataset <- section_grouped_specifics_nolab(dataset, specifically_ordered, inherent_order_label, group_var, inherent_order_group, group_specific, specifically_ordered_group, rev_group, rev_label)
### (4) Grouped Section: inherent order of grouping variables
dataset <- section_grouped_ordered(dataset, specifically_ordered, label_specific, inherent_order_label, group_var, inherent_order_group, group_specific, specifically_ordered_group, rev_group, rev_label)
### (5) Grouped Section: arranging grouping variables if group NOT inherently ordered
dataset <- section_grouped_unordered(dataset, specifically_ordered, label_specific, inherent_order_label, group_var, inherent_order_group, group_specific, specifically_ordered_group, rev_group, rev_label)
}
### topbox
dataset <- topbox(dataset, topbox)
### Put "None" & "Other" at bottom
dataset <- none_other(dataset, none_other, grouped)
### Horizontal
dataset <- horizontal_chart(dataset, horizontal, grouped)
### Stacked
dataset <- stacked_chart(dataset, stacked, grouped, inherent_order_group, specifically_ordered_group)
dataset <- stacked_chart_ms(dataset, stacked, grouped, inherent_order_group, specifically_ordered_group)
}
#overall
frequencies <- grouped_freqs %>%
order_label(
group_var = district,
horizontal = T,
#inherent_order_label = T,
#inherent_order_group = T,
#rev_label = T,
#rev_group = T,
#label_specific = 'Two',
#group_specific = 'District 2'
)
#new_group atuo feature
frequencies <- responses %>%
# group_by(QSEX) %>%
filter(!is.na(QSEX)) %>%
freqs(QWALKPARK) %>%
# mutate(group_var1 = QSEX) %>%
order_label(
# group_var = QSEX
)
frequencies <- responses %>%
freqs(
QNEWS1,
nas = F,
wt = weights
) %>%
mutate(
label = mapvalues(
label,
from = c(
1:4, 6:7
),
to = c(
'City newsletter',
'Email from the city',
'City website',
'Newspaper',
'Social Media',
'Other'
)
)
) %>%
arrange(
result %>% desc
) %>%
mutate(
label = fct_inorder(label)
)
responses <- readRDS(
'data/Lehi Panel 2018_March 29, 2018_16.06-Weighed data CNK.RDS'
)
